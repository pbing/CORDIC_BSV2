//
// Generated by Bluespec Compiler, version 2024.01 (build ae2a2fc)
//
// On Sat Mar 23 14:07:17 CET 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_request_put                O     1 reg
// response_get                   O    50 reg
// RDY_response_get               O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// request_put                    I    48
// EN_request_put                 I     1
// EN_response_get                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCORDIC_v(CLK,
		  RST_N,

		  request_put,
		  EN_request_put,
		  RDY_request_put,

		  EN_response_get,
		  response_get,
		  RDY_response_get);
  input  CLK;
  input  RST_N;

  // action method request_put
  input  [47 : 0] request_put;
  input  EN_request_put;
  output RDY_request_put;

  // actionvalue method response_get
  input  EN_response_get;
  output [49 : 0] response_get;
  output RDY_response_get;

  // signals for module outputs
  wire [49 : 0] response_get;
  wire RDY_request_put, RDY_response_get;

  // register m_itercount
  reg [3 : 0] m_itercount;
  wire [3 : 0] m_itercount$D_IN;
  wire m_itercount$EN;

  // register m_x
  reg [16 : 0] m_x;
  wire [16 : 0] m_x$D_IN;
  wire m_x$EN;

  // register m_y
  reg [16 : 0] m_y;
  wire [16 : 0] m_y$D_IN;
  wire m_y$EN;

  // register m_z
  reg [15 : 0] m_z;
  wire [15 : 0] m_z$D_IN;
  wire m_z$EN;

  // ports of submodule m_f_in
  wire [49 : 0] m_f_in$D_IN, m_f_in$D_OUT;
  wire m_f_in$CLR, m_f_in$DEQ, m_f_in$EMPTY_N, m_f_in$ENQ, m_f_in$FULL_N;

  // ports of submodule m_f_out
  wire [49 : 0] m_f_out$D_IN, m_f_out$D_OUT;
  wire m_f_out$CLR, m_f_out$DEQ, m_f_out$EMPTY_N, m_f_out$ENQ, m_f_out$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_m_iterate, WILL_FIRE_RL_m_iterate0;

  // inputs to muxes for submodule ports
  wire [16 : 0] MUX_m_x$write_1__VAL_1,
		MUX_m_x$write_1__VAL_2,
		MUX_m_y$write_1__VAL_1,
		MUX_m_y$write_1__VAL_2;
  wire [15 : 0] MUX_m_z$write_1__VAL_1, MUX_m_z$write_1__VAL_2;
  wire [3 : 0] MUX_m_itercount$write_1__VAL_1;
  wire MUX_m_itercount$write_1__SEL_1, MUX_m_itercount$write_1__SEL_2;

  // remaining internal signals
  reg [15 : 0] SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19;
  wire [49 : 0] IF_SEXT_request_put_BITS_47_TO_32_8_9_BIT_16_0_ETC___d65;
  wire [16 : 0] SEXT_request_put_BITS_31_TO_16_1___d52,
		SEXT_request_put_BITS_47_TO_32_8___d49,
		m_f_inD_OUT_BITS_32_TO_16__q1,
		m_f_inD_OUT_BITS_49_TO_33__q2,
		m_f_in_first_BITS_32_TO_16_SRA_m_itercount___d9,
		m_f_in_first_BITS_49_TO_33_SRA_m_itercount___d13,
		m_x_0_MINUS_m_y_8_SRA_m_itercount_1___d32,
		m_x_0_PLUS_m_y_8_SRA_m_itercount_1___d33,
		m_x_0_SRA_m_itercount___d35,
		m_y_8_MINUS_m_x_0_SRA_m_itercount_5___d37,
		m_y_8_PLUS_m_x_0_SRA_m_itercount_5___d36,
		m_y_8_SRA_m_itercount___d31;
  wire [15 : 0] m_z_9_MINUS_SEL_ARR_8192_4836_2555_1297_651_32_ETC___d40,
		m_z_9_PLUS_SEL_ARR_8192_4836_2555_1297_651_326_ETC___d41,
		request_put_BITS_31_TO_16__q4,
		request_put_BITS_47_TO_32__q3;

  // action method request_put
  assign RDY_request_put = m_f_in$FULL_N ;

  // actionvalue method response_get
  assign response_get = m_f_out$D_OUT ;
  assign RDY_response_get = m_f_out$EMPTY_N ;

  // submodule m_f_in
  FIFO2 #(.width(32'd50), .guarded(1'd1)) m_f_in(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(m_f_in$D_IN),
						 .ENQ(m_f_in$ENQ),
						 .DEQ(m_f_in$DEQ),
						 .CLR(m_f_in$CLR),
						 .D_OUT(m_f_in$D_OUT),
						 .FULL_N(m_f_in$FULL_N),
						 .EMPTY_N(m_f_in$EMPTY_N));

  // submodule m_f_out
  FIFO2 #(.width(32'd50), .guarded(1'd1)) m_f_out(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(m_f_out$D_IN),
						  .ENQ(m_f_out$ENQ),
						  .DEQ(m_f_out$DEQ),
						  .CLR(m_f_out$CLR),
						  .D_OUT(m_f_out$D_OUT),
						  .FULL_N(m_f_out$FULL_N),
						  .EMPTY_N(m_f_out$EMPTY_N));

  // rule RL_m_iterate0
  assign WILL_FIRE_RL_m_iterate0 = m_f_in$EMPTY_N && m_itercount == 4'd0 ;

  // rule RL_m_iterate
  assign WILL_FIRE_RL_m_iterate =
	     m_itercount != 4'd0 && m_itercount != 4'd15 ;

  // inputs to muxes for submodule ports
  assign MUX_m_itercount$write_1__SEL_1 =
	     WILL_FIRE_RL_m_iterate || WILL_FIRE_RL_m_iterate0 ;
  assign MUX_m_itercount$write_1__SEL_2 =
	     m_f_out$FULL_N && m_itercount == 4'd15 ;
  assign MUX_m_itercount$write_1__VAL_1 = m_itercount + 4'd1 ;
  assign MUX_m_x$write_1__VAL_1 =
	     m_f_in$D_OUT[32] ?
	       m_f_in$D_OUT[49:33] -
	       m_f_in_first_BITS_32_TO_16_SRA_m_itercount___d9 :
	       m_f_in$D_OUT[49:33] +
	       m_f_in_first_BITS_32_TO_16_SRA_m_itercount___d9 ;
  assign MUX_m_x$write_1__VAL_2 =
	     m_y[16] ?
	       m_x_0_MINUS_m_y_8_SRA_m_itercount_1___d32 :
	       m_x_0_PLUS_m_y_8_SRA_m_itercount_1___d33 ;
  assign MUX_m_y$write_1__VAL_1 =
	     m_f_in$D_OUT[32] ?
	       m_f_in$D_OUT[32:16] +
	       m_f_in_first_BITS_49_TO_33_SRA_m_itercount___d13 :
	       m_f_in$D_OUT[32:16] -
	       m_f_in_first_BITS_49_TO_33_SRA_m_itercount___d13 ;
  assign MUX_m_y$write_1__VAL_2 =
	     m_y[16] ?
	       m_y_8_PLUS_m_x_0_SRA_m_itercount_5___d36 :
	       m_y_8_MINUS_m_x_0_SRA_m_itercount_5___d37 ;
  assign MUX_m_z$write_1__VAL_1 =
	     m_f_in$D_OUT[32] ?
	       m_f_in$D_OUT[15:0] -
	       SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 :
	       m_f_in$D_OUT[15:0] +
	       SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 ;
  assign MUX_m_z$write_1__VAL_2 =
	     m_y[16] ?
	       m_z_9_MINUS_SEL_ARR_8192_4836_2555_1297_651_32_ETC___d40 :
	       m_z_9_PLUS_SEL_ARR_8192_4836_2555_1297_651_326_ETC___d41 ;

  // register m_itercount
  assign m_itercount$D_IN =
	     MUX_m_itercount$write_1__SEL_1 ?
	       MUX_m_itercount$write_1__VAL_1 :
	       4'd0 ;
  assign m_itercount$EN =
	     WILL_FIRE_RL_m_iterate || WILL_FIRE_RL_m_iterate0 ||
	     m_f_out$FULL_N && m_itercount == 4'd15 ;

  // register m_x
  assign m_x$D_IN =
	     WILL_FIRE_RL_m_iterate0 ?
	       MUX_m_x$write_1__VAL_1 :
	       MUX_m_x$write_1__VAL_2 ;
  assign m_x$EN = WILL_FIRE_RL_m_iterate0 || WILL_FIRE_RL_m_iterate ;

  // register m_y
  assign m_y$D_IN =
	     WILL_FIRE_RL_m_iterate0 ?
	       MUX_m_y$write_1__VAL_1 :
	       MUX_m_y$write_1__VAL_2 ;
  assign m_y$EN = WILL_FIRE_RL_m_iterate0 || WILL_FIRE_RL_m_iterate ;

  // register m_z
  assign m_z$D_IN =
	     WILL_FIRE_RL_m_iterate0 ?
	       MUX_m_z$write_1__VAL_1 :
	       MUX_m_z$write_1__VAL_2 ;
  assign m_z$EN = WILL_FIRE_RL_m_iterate0 || WILL_FIRE_RL_m_iterate ;

  // submodule m_f_in
  assign m_f_in$D_IN =
	     (SEXT_request_put_BITS_47_TO_32_8___d49[16] &&
	      !SEXT_request_put_BITS_31_TO_16_1___d52[16]) ?
	       { SEXT_request_put_BITS_31_TO_16_1___d52,
		 -SEXT_request_put_BITS_47_TO_32_8___d49,
		 request_put[15:0] + 16'd16384 } :
	       IF_SEXT_request_put_BITS_47_TO_32_8_9_BIT_16_0_ETC___d65 ;
  assign m_f_in$ENQ = EN_request_put ;
  assign m_f_in$DEQ = WILL_FIRE_RL_m_iterate0 ;
  assign m_f_in$CLR = 1'b0 ;

  // submodule m_f_out
  assign m_f_out$D_IN =
	     m_y[16] ?
	       { m_x_0_MINUS_m_y_8_SRA_m_itercount_1___d32,
		 m_y_8_PLUS_m_x_0_SRA_m_itercount_5___d36,
		 m_z_9_MINUS_SEL_ARR_8192_4836_2555_1297_651_32_ETC___d40 } :
	       { m_x_0_PLUS_m_y_8_SRA_m_itercount_1___d33,
		 m_y_8_MINUS_m_x_0_SRA_m_itercount_5___d37,
		 m_z_9_PLUS_SEL_ARR_8192_4836_2555_1297_651_326_ETC___d41 } ;
  assign m_f_out$ENQ = MUX_m_itercount$write_1__SEL_2 ;
  assign m_f_out$DEQ = EN_response_get ;
  assign m_f_out$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_SEXT_request_put_BITS_47_TO_32_8_9_BIT_16_0_ETC___d65 =
	     (SEXT_request_put_BITS_47_TO_32_8___d49[16] &&
	      SEXT_request_put_BITS_31_TO_16_1___d52[16]) ?
	       { -SEXT_request_put_BITS_31_TO_16_1___d52,
		 SEXT_request_put_BITS_47_TO_32_8___d49,
		 request_put[15:0] - 16'd16384 } :
	       { SEXT_request_put_BITS_47_TO_32_8___d49,
		 SEXT_request_put_BITS_31_TO_16_1___d52,
		 request_put[15:0] } ;
  assign SEXT_request_put_BITS_31_TO_16_1___d52 =
	     { request_put_BITS_31_TO_16__q4[15],
	       request_put_BITS_31_TO_16__q4 } ;
  assign SEXT_request_put_BITS_47_TO_32_8___d49 =
	     { request_put_BITS_47_TO_32__q3[15],
	       request_put_BITS_47_TO_32__q3 } ;
  assign m_f_inD_OUT_BITS_32_TO_16__q1 = m_f_in$D_OUT[32:16] ;
  assign m_f_inD_OUT_BITS_49_TO_33__q2 = m_f_in$D_OUT[49:33] ;
  assign m_f_in_first_BITS_32_TO_16_SRA_m_itercount___d9 =
	     m_f_in$D_OUT[32:16] >> m_itercount |
	     ~(17'h1FFFF >> m_itercount) &
	     {17{m_f_inD_OUT_BITS_32_TO_16__q1[16]}} ;
  assign m_f_in_first_BITS_49_TO_33_SRA_m_itercount___d13 =
	     m_f_in$D_OUT[49:33] >> m_itercount |
	     ~(17'h1FFFF >> m_itercount) &
	     {17{m_f_inD_OUT_BITS_49_TO_33__q2[16]}} ;
  assign m_x_0_MINUS_m_y_8_SRA_m_itercount_1___d32 =
	     m_x - m_y_8_SRA_m_itercount___d31 ;
  assign m_x_0_PLUS_m_y_8_SRA_m_itercount_1___d33 =
	     m_x + m_y_8_SRA_m_itercount___d31 ;
  assign m_x_0_SRA_m_itercount___d35 =
	     m_x >> m_itercount |
	     ~(17'h1FFFF >> m_itercount) & {17{m_x[16]}} ;
  assign m_y_8_MINUS_m_x_0_SRA_m_itercount_5___d37 =
	     m_y - m_x_0_SRA_m_itercount___d35 ;
  assign m_y_8_PLUS_m_x_0_SRA_m_itercount_5___d36 =
	     m_y + m_x_0_SRA_m_itercount___d35 ;
  assign m_y_8_SRA_m_itercount___d31 =
	     m_y >> m_itercount |
	     ~(17'h1FFFF >> m_itercount) & {17{m_y[16]}} ;
  assign m_z_9_MINUS_SEL_ARR_8192_4836_2555_1297_651_32_ETC___d40 =
	     m_z - SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 ;
  assign m_z_9_PLUS_SEL_ARR_8192_4836_2555_1297_651_326_ETC___d41 =
	     m_z + SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 ;
  assign request_put_BITS_31_TO_16__q4 = request_put[31:16] ;
  assign request_put_BITS_47_TO_32__q3 = request_put[47:32] ;
  always@(m_itercount)
  begin
    case (m_itercount)
      4'd0:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd8192;
      4'd1:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd4836;
      4'd2:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd2555;
      4'd3:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd1297;
      4'd4:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd651;
      4'd5:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd326;
      4'd6:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd163;
      4'd7: SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd81;
      4'd8: SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd41;
      4'd9: SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd20;
      4'd10:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd10;
      4'd11: SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd5;
      4'd12: SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd3;
      4'd13, 4'd14:
	  SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd1;
      4'd15: SEL_ARR_8192_4836_2555_1297_651_326_163_81_41__ETC___d19 = 16'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_itercount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (m_itercount$EN)
	  m_itercount <= `BSV_ASSIGNMENT_DELAY m_itercount$D_IN;
      end
    if (m_x$EN) m_x <= `BSV_ASSIGNMENT_DELAY m_x$D_IN;
    if (m_y$EN) m_y <= `BSV_ASSIGNMENT_DELAY m_y$D_IN;
    if (m_z$EN) m_z <= `BSV_ASSIGNMENT_DELAY m_z$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_itercount = 4'hA;
    m_x = 17'h0AAAA;
    m_y = 17'h0AAAA;
    m_z = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCORDIC_v

